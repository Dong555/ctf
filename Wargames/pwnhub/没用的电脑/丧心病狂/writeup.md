首先拖到 jadx 直接 gg……

于是解压得 Manifest:

```
Manifest-Version: 1.0
Main-Class: pwnhub.a02c83a7dbd96295beaefb72c2bee2de
```

反编译 `pwnhub/a02c83a7dbd96295beaefb72c2bee2de.class`，jadx 继续报错：

```
com.android.dx.cf.iface.ParseException: bad class file magic (cafebabe) or version (0034.0000)
```

拖进 IDEA 看，跟了几个文件，发现先验 code 满足：

```java
    static boolean b(String var0) {
        boolean var46 = false;
        String var2 = var0 + "explorerexplorerexplorerexplorerexplorerexplorerexplorerexplorerexplorerexpl";
        byte[] var1 = var2.getBytes();
        int[] var16 = new int[80];
        int var17 = 1732584193;
        int var18 = -271733879;
        int var19 = -1732584194;
        int var20 = 271733878;
        int var21 = -1009589776;

        int var24;
        int var26;
        int var136;
        int var10000;
        int var25;
        for(int var79 = 0; var79 < var1.length; var79 += 16) {
            int var22 = var17;
            int var23 = var18;
            var24 = var19;
            var25 = var20;
            var26 = var21;

            for(int var27 = 0; var27 < 80; ++var27) {
                int var28;
                int var29;
                if(var27 < 16) {
                    var16[var27] = var1[var79 + var27];
                } else {
                    var10000 = var16[var27 - 3] ^ var16[var27 - 8] ^ var16[var27 - 14];
                    var136 = var16[var27 - 16];
                    var28 = var10000 ^ var136;
                    var29 = var28 << 1 | var28 >>> 31;
                    var16[var27] = var29;
                }

                var28 = var17 << 5 | var17 >>> 27;
                var10000 = var28 + var21 + var16[var27];
                if(var27 < 20) {
                    var136 = 1518500249 + (var18 & var19 | ~var18 & var20);
                } else {
                    byte var10002 = 40;
                    if(var27 < var10002) {
                        var136 = 1859775393 + (var18 ^ var19 ^ var20);
                    } else {
                        var10002 = 60;
                        if(var27 < var10002) {
                            var136 = -1894007588 + (var18 & var19 | var18 & var20 | var19 & var20);
                        } else {
                            var136 = -899497514;
                            int var30 = var18 ^ var19 ^ var20;
                            var136 += var30;
                        }
                    }
                }

                var29 = var10000 + var136;
                var21 = var20;
                var20 = var19;
                var19 = var18 << 30 | var18 >>> 2;
                var18 = var17;
                var17 = var29;
            }

            var17 += var22;
            var18 += var23;
            var19 += var24;
            var20 += var25;
            var21 += var26;
        }

        byte var138 = 5;
        int[] var139 = new int[var138];
        var139[0] = var17;
        var139[1] = var18;
        var139[2] = var19;
        var139[3] = var20;
        var139[4] = var21;
        int[] var94 = var139;
        byte[] var100 = new byte[20];

        for(var24 = 0; var24 < 20; ++var24) {
            var25 = var94[var24 / 4];
            var26 = (3 - var24 % 4) * 8;
            var100[var24] = (byte)(var25 >>> var26);
        }

        byte[] var72 = new byte[var100.length + 2];
        System.arraycopy(var100, 0, var72, 0, var100.length);
        byte[] var140 = new byte[var72.length / 3 * 4];
        byte[] var82 = var140;
        var17 = 0;

        for(var18 = 0; var17 < var100.length; var18 += 4) {
            var82[var18] = (byte)(var72[var17] >>> 2 & 63);
            var82[var18 + 1] = (byte)(var72[var17 + 1] >>> 4 & 15 | var72[var17] << 4 & 63);
            var82[var18 + 2] = (byte)(var72[var17 + 2] >>> 6 & 3 | var72[var17 + 1] << 2 & 63);
            var82[var18 + 3] = (byte)(var72[var17 + 2] & 63);
            var17 += 3;
        }

        byte var10001;
        for(var17 = 0; var17 < var82.length; ++var17) {
            byte var31 = var82[var17];
            if(var31 < 26) {
                var82[var17] = (byte)(var82[var17] + 65);
            } else {
                var31 = var82[var17];
                var10001 = 52;
                if(var31 < var10001) {
                    var82[var17] = (byte)(var82[var17] + 97 - 26);
                } else {
                    var31 = var82[var17];
                    var10001 = 62;
                    if(var31 < var10001) {
                        var82[var17] = (byte)(var82[var17] + 48 - 52);
                        if(!var46) {
                            continue;
                        }
                    }

                    var140 = var82;
                    var136 = var17;
                    if(!var46) {
                        var31 = var82[var17];
                        var10001 = 63;
                        if(var31 < var10001) {
                            var82[var17] = 43;
                            continue;
                        }

                        var140 = var82;
                        var136 = var17;
                    }

                    var140[var136] = 47;
                }
            }
        }

        var10000 = var82.length;
        var10001 = 1;

        for(var17 = var10000 - var10001; var17 > var100.length * 4 / 3; --var17) {
            var82[var17] = 61;
        }

        return (new String(var82)).equals("FVaFsOGplhi32uir9nCbgQTOLIM=");
    }
```

搜下常量，看一看猜一猜，感觉是：

```python
# sha1 无 padding，len(input) == 4
base64(sha1(input + 'explorerexplorerexplorerexplorerexplorerexplorerexplorerexplorerexplorerexpl')) == "FVaFsOGplhi32uir9nCbgQTOLIM="
```

然而测试下来发现不对，大概是改过的 sha1，真蛋疼……

尝试直接 `java -jar pwnhub.jar` 暴力，速度太慢。
于是直接把函数复制出来写个 java 暴力，得 code: `mdzz`。

继续看 `e9b8eb59aee1bca0a57fa2091b3724b9.class`，
继承了 ClassLoader，重写了 findClass，将其他的 class 文件全部加密。
文件名为类名 md5，大写字母（未加密文件大概全小写字母）。
加密方法为 AES：

```python
AES.new(md5sum('mdzz'), IV='****************', mode=AES.MODE_CBC).encrypt(content)
```

于是全部解密（解密完后可以拖给网上在线 decompile 工具反编译）。

继续看发现下面类似代码不停迭代：

```java
public static byte[] i(byte[] a, int[] b) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    b[2] ^= 458539788;
    String d = "pwnhub." + y("#\u001b<k8");
    Class c = Class.forName(d);
    Method i = c.getMethod("i", new Class[]{(new byte[0]).getClass(), (new int[0]).getClass()});
    return (byte[])((byte[])i.invoke((Object)null, new Object[]{a, b}));
}

private static String y(String a) {
    byte[] b = a.getBytes();

    for(int i = 0; i < 5; ++i) {
        switch(i) {
        case 0:
            b[i] = (byte)(b[i] ^ 84);
            break;
        case 1:
            b[i] = (byte)(b[i] ^ 118);
            break;
        case 2:
            b[i] = (byte)(b[i] ^ 69);
            break;
        case 3:
            b[i] = (byte)(b[i] ^ 29);
            break;
        case 4:
            b[i] = (byte)(b[i] ^ 95);
        }
    }

    return new String(b);
}
```

每回解密出一个新的类名，然后调用，同时修改下第二个参数。
由于代码格式固定，于是写个脚本跟着跑，找到最终节点，顺便把第二个参数的结果算下。

最后走到 `frsu` 类一加密函数：

```java
static byte[] b(byte[] var0, int[] var2) throws Exception {
    int i;
    int[] var3 = new int[]{943331329, 170788368, 1008414755, 187049985, 1010368540, 220604441, 940377620, 255209728, 689771012, 221709344, 957157408, 892536332, 722417666, 1026621720, 655302664, 890966315};
    int[] vark = new int[]{1847617210, 1994607775, 1906299266, 1443467998, 1753140052, 782026644, 743697037, 1500018807, 1015162722, 141403752, 1057274701, 1430471406, 921937966, 1419221067, 962664086, 2133607337};
    for (int i2 = 0; i2 < 16; ++i2) {
        int[] arrn = var2;
        int n = i2;
        arrn[n] = arrn[n] ^ vark[i2];
    }
    int[] var11 = new int[32];
    for (i = 0; i < 16; ++i) {
        var11[i] = var3[i];
    }
    for (i = 0; i < 16; ++i) {
        var11[i + 16] = var2[i];
    }
    byte[] var39 = var0;
    int[] var12 = new int[]{16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756};
    int[] var13 = new int[]{-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, Integer.MIN_VALUE, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, Integer.MIN_VALUE, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, Integer.MIN_VALUE, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, Integer.MIN_VALUE, -2146435040, -2146402272, 1081344};
    int[] var14 = new int[]{520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584};
    int[] var15 = new int[]{8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928};
    int[] var16 = new int[]{256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080};
    int[] var17 = new int[]{536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312};
    int[] var18 = new int[]{2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154};
    int[] var19 = new int[]{268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696};
    int var20 = var39.length;
    int var72 = var20 % 8;
    if (var72 != 0) {
        System.out.println("try again");
        System.exit(0);
    }
    var72 = 2;
    int[] var21 = new int[var72];
    byte[] var22 = new byte[var20];
    int var23 = var20 / 8;
    for (int var24 = 0; var24 < var23; ++var24) {
        int var26;
        int var25 = var24 * 8;
        for (var26 = 0; var26 < 2; ++var26) {
            var21[var26] = (var39[var25 + var26 * 4] & 255) << 24 | (var39[var25 + var26 * 4 + 1] & 255) << 16 | (var39[var25 + var26 * 4 + 2] & 255) << 8 | var39[var25 + var26 * 4 + 3] & 255;
        }
        int var31 = 0;
        int var29 = var21[0];
        int var28 = var21[1];
        int var27 = (var29 >>> 4 ^ var28) & 252645135;
        var27 = ((var29 ^= var27 << 4) >>> 16 ^ (var28 ^= var27)) & 65535;
        var27 = ((var28 ^= var27) >>> 2 ^ (var29 ^= var27 << 16)) & 858993459;
        var27 = ((var28 ^= var27 << 2) >>> 8 ^ (var29 ^= var27)) & 16711935;
        var28 ^= var27 << 8;
        var28 = var28 << 1 | var28 >>> 31 & 1;
        var27 = ((var29 ^= var27) ^ var28) & -1431655766;
        var29 ^= var27;
        var28 ^= var27;
        var29 = var29 << 1 | var29 >>> 31 & 1;
        for (int var30 = 0; var30 < 8; ++var30) {
            var27 = var28 << 28 | var28 >>> 4;
            var26 = var18[(var27 ^= var11[var31++]) & 63];
            var26 |= var16[var27 >>> 8 & 63];
            var26 |= var14[var27 >>> 16 & 63];
            var26 |= var12[var27 >>> 24 & 63];
            var27 = var28 ^ var11[var31++];
            var26 |= var19[var27 & 63];
            var26 |= var17[var27 >>> 8 & 63];
            var26 |= var15[var27 >>> 16 & 63];
            var27 = var29 << 28 | (var29 ^= (var26 |= var13[var27 >>> 24 & 63])) >>> 4;
            var26 = var18[(var27 ^= var11[var31++]) & 63];
            var26 |= var16[var27 >>> 8 & 63];
            var26 |= var14[var27 >>> 16 & 63];
            var26 |= var12[var27 >>> 24 & 63];
            var27 = var29 ^ var11[var31++];
            var26 |= var19[var27 & 63];
            var26 |= var17[var27 >>> 8 & 63];
            var26 |= var15[var27 >>> 16 & 63];
            var28 ^= (var26 |= var13[var27 >>> 24 & 63]);
        }
        var28 = var28 << 31 | var28 >>> 1;
        var27 = (var29 ^ var28) & -1431655766;
        var29 ^= var27;
        var29 = var29 << 31 | var29 >>> 1;
        var27 = (var29 >>> 8 ^ (var28 ^= var27)) & 16711935;
        var27 = ((var29 ^= var27 << 8) >>> 2 ^ (var28 ^= var27)) & 858993459;
        var27 = ((var28 ^= var27) >>> 16 ^ (var29 ^= var27 << 2)) & 65535;
        var27 = ((var28 ^= var27 << 16) >>> 4 ^ (var29 ^= var27)) & 252645135;
        var21[0] = var28 ^= var27 << 4;
        var21[1] = var29 ^= var27;
        int var32 = var24 * 8;
        for (int var33 = 0; var33 < 2; ++var33) {
            var22[var32 + var33 * 4] = (byte)(var21[var33] >>> 24);
            var22[var32 + var33 * 4 + 1] = (byte)(var21[var33] >>> 16);
            var22[var32 + var33 * 4 + 2] = (byte)(var21[var33] >>> 8);
            var22[var32 + var33 * 4 + 3] = (byte)var21[var33];
        }
    }
    byte var66 = var22[var22.length - 1];
    return var22;
}
```

深坑从此开始……

首先查常数可发现是 DES，然而没有密钥展开，仔细看发现是直接给（算）出了轮密钥，同时无 padding。
不放心的话可以修改代码重新编译加密后篡改 jar 包打 log 查看，避免算错。

然后找份 DES 实现，改掉轮密钥发现结果不对。
打 log 一轮轮对比，一点点定位，检查有木有细节被改。
最后发现：

1. 密钥 32 个 int，需要相邻两个两个一组交换；
1. 函数第 65 行代码 `var27 = var29 << 28 | (var29 ^= (var26 |= var13[var27 >>> 24 & 63])) >>> 4;` 有问题，按照 DES 正确实现应该是：

    ```java
    var29 ^= (var26 |= var13[var27 >>> 24 & 63])
    var27 = var29 << 28 | var29 >>> 4;
    ```

    按照看到的代码实际执行效果是先 `var29 << 28`，然后再修改的 var29，不确定是故意的还是哪里 bug 了。
    （最后感觉应该是在线反编译的问题，IDEA 看到的代码是分两行写的，没有问题）

于是最后把 DES 实现的轮密钥替换后，调用解密得到 flag：`e9b8eb59aee1bca0a57fa2091b3724b9`

*PS：看了下另外几个 WriteUp，发现都是加解密密钥展开结果不一样（按一定规则交换），*
*貌似就我找这个鬼实现加解密密钥展开结果是相同的，于是加密轮密钥相邻两个反了只会影响我，*
*瞬间感觉好心塞 `(T_T)`*

*DES 地址：[https://github.com/cballou/SPF30/blob/master/spf30.php#L202]()，JS 版，非万不得已坚决不写 Java！*
